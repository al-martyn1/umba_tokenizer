
#struct PredicateDefinition

Определение предикатов. Предикат - это дополнительное условие при переходе по событию.
                        
#!snippet{} umba/tokenizer/parsers/ufsm/basic_types.h#`struct PredicateDefinition`-{};

## Поля структуры

<val-list>

- positionInfo
информация о позиции в исходных файлах.

- name
имя (название) предиката.

- description
описание предиката.

- flags
флаги (опции) предиката (PredicateFlags).

- expression
логическое выражение для пользовательского (не внешнего) предиката.

- validForList
список событий, для которых предикат может использоваться.

</val-list>


## Флаги (PredicateFlags flags)

<val-list>

- PredicateFlags::none
флаги не заданы.

- PredicateFlags::external
Преликат является внешним, если установлен данный флаг. В противном случае предикат является составным, 
и `expression` содержит валидное логическое выражение.

- PredicateFlags::validFor
предикат содержит список событий в векторе `validForList`, для которых данный предикат может исползоваться. Используется для проверок и оптимизаций.

</val-list>


## Методы

<val-list>

- getCanonicalName
формирует "каноническое" имя объекта. В данном случае, возвращает просто имя объекта, которое является его полем/членом.

</val-list>

## Описание

Предикаты могу быть внешними и составными.

Составные предикаты - это логическое выражение (булева формула), состоящее из 
предикатов, операций `&`и `|`, а также группирующих скобок.

Предикаты, входящие в выражение, могут быть внешними и составными.
После обработки это выражение раскрывается так, что содержит только внешние предикаты.

**Примеры описаний предикатов, внешних и составных:**
```
greenLightIsOn : external - "Checks the GREEN light is ON"; // valid-for {toggleGreen}
isIndexBrace : external valid-for {evOperator} - "Оператор - индексная скобка";
isAnyOpenBrace = isOpenBrace & pTrue; // Оставляем без описания
```

**Примечание**
После того, как в описание автомата добавляются определения событий и предикатов из используемых
дефиниций и унаследованных автоматов, для всех пользовательских предикатов формируется список
validForList.

**Примечание по терминологии**
Дефиниции (`definitions`) полностью аналогичны автоматам, 
но из дефиниций нельзя произвести генерацию автомата в диаграмму или код.
Автоматы можно переиспользовать (унаследовать) при помощи ключевого слова `inherits`,
дефиниции переиспользуются при помощи ключевого слова `uses`.

**Примечание по реализации**
Нужно продумать, как происходит формирование списков действий, событий, предикатов и переходов
при наследовании `inherits` автоматов (и использовании `uses` дефиниций).
Пока есть идея, что непосредственно описанные в автомате сущности первичны, 
а то, что мы поттягиваем из ранее определенных автоматов и дефиниций добавляется (и может 
переопределять сущности автомата), тогда выражение `override` в `inherits`/`uses`
имеет смысл. 
Иначе же у нас сущности берутся из первой базы (но в принципе, `override`
имеет смысл для последущих `inherits`/`uses`), и надо как-то уметь их переопределять
в описании текущего автомата - для каждого раздела задавать override?
в принципе, тоже рабочий вариант. Как же быть?

Пример объявления автомата:
```
state-machine TrafficLightPedestrian : 
//inherits TrafficLightBase,
uses TrafficLightCommands, 
   TrafficLightEventsActions 
     // возможные коллизии молча переписываются более поздними значениями
     override {actions, events, predicates, states, transitions} 
- "Pedestrian Traffic Light (Red-Green)"
```
