# Roadmap для Umba FSM-GEN


## Расширение языка описания ДКА и как оно работает (или должно работать)

- [ ] Добавить transition-атрибут для состояния - говорит о том, что состояние не "фиксируется":
      при переходе в любое состояние выполняется:
      - устанавливается новое состояние (целевое состояние)
      - выполняются все exit-действия (actions) исходного состояния
      - выполняются все действия (actions) перехода
      - выполняются все enter-действия (actions) нового состояния.
      - после этого производится проверка, является ли состояние transition-состоянием.
        Если является, то инициируется переход из текущего transition-состояниея в следующее состояние.
        При выборе нового состояния учитываются предикаты, а также выполняются все exit/transition/enter actions.

        Цепочки transition-состояний не поддерживаются. И не особо нужно, и грозит гемором.
        Нельзя - и всё. Язык не позволяет.

- [ ] Переходы из transition-состояний не должны иметь никаких событий в описании переходов - только
      предикаты - список events должен быть пустой. Непустой список events генерирует ошибку. В то же
      время пустой список events является ошибкой для обычных состояний.
      Теоретически, при переходе из transition-состояния может не быть как events, так и predicates.
      Это означает безусловный переход. Не понятно, зачем бы такое было бы нужно, но возможность оставим.


## Генерация кода ДКА на целевых языках

- [ ] Предварительно, можно использовать `Mustache` - он вроде довольно простой, реализация обычно header-only 
      в одном/нескольких хидерах, есть для многих языков, в т.ч. для C++. Если `Mustache` не будет вытащивать,
      есть другие варианты.

- [ ] `Inja` - Header-only библиотека, синтаксис похож на (Python) Jinja2, говорят, проста в использовании.

- [ ] `Jinja2C++` - Полная поддержка синтаксиса (Python) Jinja2 (говорят), высокая производительность. 
      Недостаток - автор проекта 'FlexFerrum' умер, но проект вроде начало тащить какое-то сообщество.
      Проект крут, но не очень прост, и перспективы не ясны.


## Генерация графического представления ДКА

- [X] Генерация через GraphViz - получается какое-то полное говно, кроме простейших случаев. Да и простейшие случаи 
      выглядят как какашка.

- [ ] Делаем матрицу "занятости" - каждому биту в матрице соответствует квадратная область, например, 10 условных пикселей.
      Если у нас в этих десяти пикселях что-то рисуется (или они покрываются какой-то фигурой), то ставим признак занятости.
      Проблемы могут быть с овалами и элипсами, и, вероятно, с кривыми Безье (надо просто разбираться поплотнее, а это лень).
      Для начала, не будем использовать для отображения состояний ничего, кроме окружностей.

- [ ] Сначала рисуем отдельные состояния с отдельными матрицами занятости, и рисуем там только переходы в самих себя.
      Сначала переходы рисуем сверху и снизу, если переходов больше шести, добавляем лево, больше девяти - добавляем право.
      Выходы и входы рисуем симметрично вертикальной (для верхних и нижних переходов), и симметрично горизонтальной оси
      (левые и правые переходы). Первый переход делаем с углом 10 градусов от оси симметрии (всего 20), затем прибавляем 
      по 5 градусов (с каждой стороны от оси). Если взять 4 перехода (со всех четырёх сторон всего 20 вполне с запасом) -
      10+5+5+5=25, в каждой четверти по диагонали у нас остаётся 90-2\*25=40 градусов  для переходов в другие состояния 
      и входов из других состояний. Это 30-60 - 30, 35, 40, 45, 50, 55, 60 - 7, четыре четверти - 7\*4=28 переходов в другие
      состояния - с запасом. Но, в целом, у нас может быть 360/5-4=72-4=68 входов и выходов. Больше - проблема. Но малореально,
      что такое будет.
      UPD: надо уметь рисовать граф с переходами в себч для состояния с приоритетом верх-низ, низ-верх, лево-право, право-лево.

- [ ] При рисовании переходов в самих себя будем использовать форму треугольника с закруглёнными углами, стоящего на вершине
      (для перехода, отображаемого сверху). При этом у нас будет "полка", на которой можно разместить информацию о переходе.
      Размер треугольника минимально выбирается так, чтобы на полку влезали все необходимые надписи.
      UPD: не треугольник, а домик с треугольной крышеей, стоящий на крыше вверх головой (если мы говорим об отображении перехода сверху).

- [ ] Действия по переходу рисуются в метке у перехода. Там отображаются все действия: выходные действия исходного состояния,
      действия перехода, входные действия целевого состояния. В языке описаиня ДКА это записывается в разных местах,
      но на графическом представлении должно быть максимально информативно показано, что происходит по тем или иным переходам.

- [ ] После рисования отдельных состояний на отдельных сюрфейсах мы можем оценить, сколько места они занимают, и далее располагать 
      их с учётом этого. Выбираем наверное самый максимальный размер по X/Y, и оставляем ещё вокруг какой-то запас для линий переходов.
      Или размер берём как есть для каждого состояния.
     
- [ ] Расположение узлов состояний на графе ДКА. Варианты:
      - по кругу (типа GraphViz neato алгоритм)
      - линейно в "строку" с переносом строки
      - "хаотично" с учетом связанности. Что-то на тему пружинного отображения графа.


## Дополнения в язык описания ДКА

- [ ] в части поддержки графического отображения:

      - сделать секцию в описании state-machine, которая описывает или хотя бы намечает хинты, как и что 
        рисовать на графе автомата.
      - задание общего стиля отображения
        - linear - в строку, с переносом на следующую
        - circle - а-ля neato граф GraphViz
        - что-то ещё?








