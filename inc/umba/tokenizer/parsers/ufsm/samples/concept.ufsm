// Описание ДКА

// Коментарии могут быть как в стиле C/C++
# так и в стиле bash
// Многострочные коментарии не поддерживаются
// Или стоит добавить поддержку многострочных коментарием в стиле C/C++?


// Автомат сам по себе не использует никакий стек состояний, но стек состояний и операции
// с ним могут быть быть частью кода поддержки автомата, который пишется на целевом языке программирования.

// Переменные, дополнительные данные входного события, а также данные для действий
// хранятся в "контексте" автомата, это может быть класс или структура. 
// Контекст автомата пишется на целевом языке программирования.

// Временные события, например, события таймеров, приходят как и все другие события, в общем порядке.
// Например, секундный таймер будет просто генерировать события evTimer1000ms.
// Если нам нужно создать отложенное событие, пользователь должен создать действие в коде 
// поддержки автомата, например, startDebounceTimer, которое запустит какой-то таймер, который через
// заданный в коде поддержки автомата интервал сгенерирует событие evDebounceTimerExpires 
// (мы не зашиваем константы в описание автомата, они могут быть настраивыми).

// Предикаты, также как и действия (actions), не принимают никаких параметров.
// Если их надо как-то параметризовать, то следует создать несколько предикатов или 
// действий, которые вызывают универсальный предикат (или действие) с нужным параметром.

// Супер-состояния пока не будем делать. Это направление дальнейшего возможного развития.
// Супер-состояние - не может использоваться само по себе, но может содержать действия и переходы,
// которые могут наследоваться конечными использумыми в ДКА состояниями. Что-то типа родительского класса C++
// с базовой реализацией части методов.

// Вложенные состяния пока не реализовываем - их можно, хоть, возможно, и с некоторым дублированием,
// реализовывать при помощи одноуровнего ДКА.

// Глобальные переходы - переходы из всех состояний или из группы состояний
// по одному событию и одинаковым guard-условиям переходов.
// Пока не будем реализовывать.


// Всё расширенные фичи, которые в данный момент не предполагаются к реализации, могут
// быть реализованы позже, если в них появится необходимость.
// Пока же можно жить и с тем, что уже запланированно.

// Графическое отображение ДКА планируется, для этого предполагается генерация
// в GraphVIZ и/или PlantUML описания FSM.

// Также глянуть тут - https://github.com/statelyai/xstate


fsm: ExpressionTreeBuilder - "Автомат разбора потока лексем в дерево выражения";

// В примере оперирую понятиями, связанными с построением дерева выражения,
// но это не значит, что генератор ДКА предназначен только для разбора языков ЯП.
// Точно также можем описать и алгоритм работы какого-нибудь робота или станка ЧПУ.

// Как объявлять блоки?
// Можно через имя блока и последующие блоковые символы, типа {}
// Или контекстно-зависимо, после имени секции, типа
// events:

// Давай попробуем блоки


events // Объявляем возможные события
{
  // Это предикаты для событий, их должен описать пользователь в коде обвязки
  // Предикаты - это обычно функции без аргументов, но зависит от целевого языка и шаблона генерации

  // Они не должны пересекаться, т.е. только один из них должен возвращать true
  // Они оперируют над пришедшим событием, которое сохранено в классе автомата, 
  // или является аргументом вызова.
  // В генераторе ДКА мы не можем это проконтролировать, это остаётся на совести программиста, пишущего обвязку.

  evBoolLiteral : external -"Пришел булев литерал";
  evIntLiteral : external;
  evFloatLiteral : external;
  evStringLiteral : external;
  evIdentifier : external;
  evOperator : external - "Пришел оператор, в т.ч. скобка, в т.ч. и скобка вызова функции";

  //
  evFin : external - "У токенизатора закончился вход - финализируемся - построение дерева выражения, или выдача ошибки, если выражение закончилось неожиданно";

  // Составные события, для упрощения
  // Тут допустимы только логические выражения
  // Составные события будем помещать в отдельную note при визуализации автомата

  evIntegralLiteral = evBoolLiteral | evIntLiteral - "Пришел интегральный литерал";
  evLiteral = evIntegralLiteral | evFloatLiteral | evStringLiteral - "Пришел любой литерал";

}

actions
{
  // Элементарные действия, их должен описать пользователь в коде обвязки

  doSomething : external - "Что-то делаем";
  doOther : external - "Делаем что-то другое";
  pushState : external - "У нас автомат со стеком, сохраняем состояние";
  popState : external - "У нас автомат со стеком, восстанавливаем состояние";

  putPrefixUnaryOp : external - "Присунули унарный префиксный оператор";
  putBinaryOp : external - "Присунули бинарный оператор";

  doLoopEnter : external - "Действие при входе в самого себя";
  doLoopLeave : external - "Действие при выходе из самого себя";


  // Составные действия, в коде обвязки их не имеет смысла описывать, они составные
  // для любого целевого языка
  // Составные действия будем помещать в отдельную note при визуализации автомата, как вариант

  pushStateDoSomething = { pushState; doSomething; } - "Засунули состояние на стек и что-то сделали";
  popStateDoOther = { popState; doOther; } - "Восстановили состояние из стека и сделали что-то другое";


}

predicates
{
    // Предикаты - это функции без аргументов (пока, дальше будет видно)
    // для использования в guard conditions событий

    pFalse : external - "Вегда возвращает false";
    pTrue  : external - "Всегда возвращает true";

    isOpenBrace : external - "Оператор - открывающая скобка (работает для всех типов скобок)";

    // Другой вариант, с заданием списка валидных событий для данного предиката
    isFnCallBrace : external valid for {evOperator} - "Оператор - скобка вызова функции";
    isOpenFnCallBrace = isFnCallBrace & isOpenBrace - "Оператор - открывающая скобка вызова функции";

    isGrouppingBrace : external valid for {evOperator} - "Оператор -  скобка (группирующая)";
    isOpenGrouppingBrace = isGrouppingBrace & isOpenBrace - "Оператор - открывающая скобка (группирующая)";

    isIndexBrace : external valid for {evOperator} - "Оператор - индексная скобка";
    isOpenIndexBrace : isIndexBrace & isOpenBrace - "Оператор - открывающая индексная скобка";

    isOpMayBeUnaryPrefix : external valid for {evOperator};

    isOpPreceedencePrevLessThanCurrent : external valid for {evOperator} - "Текущий оператор с меньшим приоритетом, чем предыдущий";

    // Составной предикат, не имеет особого смысла, просто для примера
    isAnyOpenBrace = isOpenBrace & pTrue; // Оставляем без описания
}


// transitions{} // А нужны ли нам переходы отдельно от состояний? 


states // state actions and transitions
{

  // Состояния заранее не определяем
  // Чекаем потом, когда всё прочитали

  stWaitPrefixUnaryOpOrBinaryOperand : initial - "Ожидаем унарный оператор или операнд бинарного оператора"
  {
    actions
    {
        enter - "Описание, что делаем при входе в состояние" { // что-то делаем всегда при входе в состояние
          doSomething; doOther;
        }

        leave - "Описание, что делаем при выходе из состояния" { // что-то делаем всегда при выходе из состояния
          doOther; doSomething; 
        }

        self-enter [inherits [enter|leave] [[call before|after]]] { 
          // действия при залупинге при входе в состояние, если не указано, что наследуем, 
          // то наследуем действия по входу в состояние (другой вариант - ничего не "наследуем").
          // "наследуем" действия при входе/выходе, добавляем действия, указанные в enter/leave акции до или после
          // объявленных в данной сексции
          // иначе по селф-входу ничего не делаем

          doLoopEnter;
        }
    
        self-leave [inherits [enter|leave] [[before|after]]]
        { // действия при залупинге при входе в состояние, если не указано, что наследуем, 
          // то наследуем действия по выходу из состояния
          // иначе по селф-выходу ничего не делаем

          doLoopLeave;
        }

        # Может, сделать найси токены selfe/selfle (self-e/self-l/enter-self/enter-s/leave-self/leave-s)?
    
    }
--------
        starting : initial - "Starting"
        {
            // State actions
            enter { turnOff; startAliveTimer; }
            leave {} // Можно не указывать
            self-enter; // : inherits enter;
            self-leave; // Можно не указывать
            // self-leave : inherits enter call-before, parent-enter call-after; // { }
        }
--------



    transitions # Описываем переходы из состояния - bash-стайл коммент
    {
      // событие -> конечное состояние [? guard] [[: action | actions-block] [[- описание]]]
      // Если у нас несколько действий, то они оформляются в блок, в котором они перечисляются через точку с запятой
      // Если у нас одно действие, то его можно явно указать, без точки с запятой
      // Для того, чтобы не забывать ставить дополнительное двоеточие для пустого guard-выражения, будем использовать символ вопроса ('?')
      // вместо унифицированного двоеточия.
      // Таким образом, после '->' должно следовать конечное состояние перехода
      // после '?' - дополнительное условие перехода
      // после двоеточия - действия по переходу
      // после минуса/дефиса - описание перехода

      // Ключевое слово self означает самое себя для следующего состояния (звёздочка mul означает то же самое, если используется в качестве целевого состояния).

      // Если по событию есть несколько переходов, то сначала обрабатываются все переходы по данному событию с дополнительными guard-условиями,
      // потом, если есть, условие по событию без дополнительных guard-условий,
      // затем используется переход по событию "звёздочка" (mul, '*')

      // При генерации автомата первыми проверяются наиболее длинные guard-условия - с наибольшим количеством guard-предикатов.

      // Звёздочка mul '*' означает все остальные необработанные события, если используется как имя события.

      // Входное событие - такой же предикат, как и guard conditions
      // Полное условие срабатывания перехода выглядит так: evSomeInput & (guard-conditions)

      // Переход в самое себя по guard условию isOpMayBeUnaryPrefix
      // Префиксных операторов может быть целая пачка
      evOperator -> self ? isOpMayBeUnaryPrefix - "Тут какой-то унарный оператор, возвращаемся обратно в текущее состояние, если оператор реально префиксный";
      evOperator -> stFin - "Тут у нас переход по событию evOperator без каких-либо дополнительных guard-условий"; //

      evLiteral  -> stWaitBinaryOpOrFnCall : { pushStateDoSomething; popStateDoOther; } - "Тут какой-то литерал, после него ждём бинарный оператор, или function call";
      
      // No actions on WhatTheFuck
      // * -> stFin : {} : errWhatTheFuck
      * -> stErr : : errWhatTheFuck - "Что-то пошло не так";
    }

  }

  stFin : final - "Нормальное завершение работы"; // У нас тут нет блока описания состояния с его actions и transitions - это конечное состояние, и такой блок не нужен

  stErr : final - "Аварийное завершение работы";

}