# Deepseek предлагает разбор HTTP

> Можешь придумать какой-нибудь конечный автомат, чтобы у него было до 5-7 состояний. 
> Несколько входных событий, и так, чтобы какое-то или какие-то события подразделялись 
> на независимые события и/или уточнялись дополнительными условиями. Может, разбор 
> какого-то протокола, или что-то подобное. Желательно, чтобы это было что-то известное 
> и/или узнаваемое.


Отличная идея! Давайте спроектируем конечный автомат для разбора упрощенной версии **HTTP-запроса**. Это узнаваемо, практично и хорошо ложится на концепцию состояний с уточняющими условиями.

### Конечный автомат: "Парсер HTTP-запроса"

**Цель:** Разобрать входящий поток байтов и определить, является ли он корректным HTTP-запросом, и извлечь его метод и целевой URL.

---

### 1. Входные события (Символы алфавита)

Здесь мы как раз введем независимые события и уточняющие условия.

*   `LETTER` : Любая буква (a-z, A-Z). *Уточняющее условие: является ли эта буква частью метода или URL.*
*   `DIGIT` : Любая цифра (0-9).
*   `SPACE` : Символ пробела (или табуляции).
*   `SLASH` : Символ '/'.
*   `NEWLINE` : Символ перевода строки (`\n`). *Уточняющее условие: является ли он одиночным (`\r\n` vs `\n`) или двойным (конец заголовков).*
*   `OTHER` : Любой другой символ, не попавший в категории выше.

---

### 2. Состояния автомата (6 состояний)

1.  **`START`** - Начальное состояние. Ожидание начала запроса.
2.  **`READ_METHOD`** - Чтение HTTP-метода (GET, POST и т.д.).
3.  **`EXPECT_SPACE_AFTER_METHOD`** - Ожидание пробела после метода.
4.  **`READ_URI`** - Чтение URI (пути к ресурсу, например, `/index.html`).
5.  **`EXPECT_SPACE_AFTER_URI`** - Ожидание пробела после URI.
6.  **`READ_VERSION`** - Чтение версии HTTP-протокола (например, `HTTP/1.1`).
7.  **`EXPECT_NEWLINE`** - Ожидание перевода строки для завершения стартовой строки.
8.  **`ERROR`** - Состояние ошибки. Любое некорректное событие переводит автомат сюда.
9.  **`SUCCESS`** - Успешный разбор стартовой строки запроса.

---

### 3. Диаграмма переходов (описательно)

| Текущее состояние | Входное событие | Условие / Действие | Следующее состояние |
| :--- | :--- | :--- | :--- |
| **START** | `LETTER` | Начинаем записывать метод. | **READ_METHOD** |
| **START** | Любое другое | | **ERROR** |
| | | | |
| **READ_METHOD** | `LETTER` | Продолжаем записывать метод. | **READ_METHOD** |
| **READ_METHOD** | `SPACE` | Метод прочитан. Проверить, является ли он допустимым (GET, POST...). | **EXPECT_SPACE_AFTER_METHOD** |
| **READ_METHOD** | Любое другое | | **ERROR** |
| | | | |
| **EXPECT_SPACE_AFTER_METHOD** | `SPACE` | Игнорируем лишние пробелы. | **EXPECT_SPACE_AFTER_METHOD** |
| **EXPECT_SPACE_AFTER_METHOD** | `SLASH` | Начинается URI. Начать записывать URI. | **READ_URI** |
| **EXPECT_SPACE_AFTER_METHOD** | Любое другое | | **ERROR** |
| | | | |
| **READ_URI** | `LETTER`, `DIGIT`, `SLASH`, `OTHER` (допустимый) | Продолжаем записывать URI. | **READ_URI** |
| **READ_URI** | `SPACE` | URI прочитан. | **EXPECT_SPACE_AFTER_URI** |
| **READ_URI** | Любое другое (недопустимый символ для URI) | | **ERROR** |
| | | | |
| **EXPECT_SPACE_AFTER_URI** | `SPACE` | Игнорируем лишние пробелы. | **EXPECT_SPACE_AFTER_URI** |
| **EXPECT_SPACE_AFTER_URI** | `LETTER` | Первая буква версии ('H' из "HTTP"). Начать записывать версию. | **READ_VERSION** |
| **EXPECT_SPACE_AFTER_URI** | Любое другое | | **ERROR** |
| | | | |
| **READ_VERSION** | `LETTER`, `DIGIT`, `SLASH`, `.` | Продолжаем записывать версию. | **READ_VERSION** |
| **READ_VERSION** | `NEWLINE` | Проверить, что версия имеет формат `HTTP/x.y`. | **SUCCESS** |
| **READ_VERSION** | Любое другое | | **ERROR** |
| | | | |
| **SUCCESS** | (Конец работы автомата для этой задачи) | | |
| **ERROR** | (Конец работы автомата) | | |

---

### 4. Пример работы автомата

**Входная строка:** `GET /index.html HTTP/1.1\n`

1.  **START**: Видим `G` (`LETTER`) -> Переход в **READ_METHOD**. Метод = "G".
2.  **READ_METHOD**: Видим `E` (`LETTER`) -> Метод = "GE". Остаемся в **READ_METHOD**.
3.  **READ_METHOD**: Видим `T` (`LETTER`) -> Метод = "GET". Остаемся в **READ_METHOD**.
4.  **READ_METHOD**: Видим ` ` (`SPACE`) -> Переход в **EXPECT_SPACE_AFTER_METHOD**. Метод "GET" корректен.
5.  **EXPECT_SPACE_AFTER_METHOD**: Видим `/` (`SLASH`) -> Переход в **READ_URI**. URI = "/".
6.  **READ_URI**: Видим `i` (`LETTER`) -> URI = "/i". Остаемся в **READ_URI**.
    *   ... (читаем `index.html`) ...
7.  **READ_URI**: Видим ` ` (`SPACE`) -> Переход в **EXPECT_SPACE_AFTER_URI**.
8.  **EXPECT_SPACE_AFTER_URI**: Видим `H` (`LETTER`) -> Переход в **READ_VERSION**. Версия = "H".
9.  **READ_VERSION**: Читаем оставшуюся часть `TTP/1.1`.
10. **READ_VERSION**: Видим `\n` (`NEWLINE`) -> Переход в **SUCCESS**.

**Результат:** Автомат в состоянии **SUCCESS**. Извлеченные данные: Метод = `GET`, URI = `/index.html`, Версия = `HTTP/1.1`.

---

### 5. Пример с ошибкой

**Входная строка:** `GETT /index.html HTTP/1.1\n`

1.  ... Автомат соберет метод "GETT".
2.  В состоянии **READ_METHOD** при получении `SPACE` автомат проверяет уточняющее условие: "Является ли собранный метод допустимым?".
3.  "GETT" не является стандартным HTTP-методом -> Переход в состояние **ERROR**.

Этот автомат наглядно показывает:
*   **Конечное число состояний**.
*   **Независимые входные события** (`LETTER`, `DIGIT` и т.д.).
*   **Уточняющие условия**, проверяемые при переходах (валидность метода, версии).
*   **Узнаваемость** (разбор HTTP).
*   **Практическую применимость** (такие автоматы лежат в основе парсеров веб-серверов).


> NEWLINE - тут не должно быть уточняющего условия, а, вероятно, должно быть добавлено ещё одно состояние. 
> Скорее всего, даже это и не требуется. В ожидании выражения HTTP-заголовка (сюда попадаем после окончания 
> предыдущего заголовка по переводу строки), если получаем перевод строки - то разбор заголовков можно 
> считать законченным.
>
LETTER - является ли символ частью метода или URL - должно определяться состоянием автомата, ты придумал 
> плохой пример. Подумай лучше.


Вы абсолютно правы, мои примеры условий были некорректны. Давайте перепроектируем автомат правильно, чтобы логика определялась именно состояниями, а не уточнениями в событиях.

### Конечный автомат: "Парсер стартовой строки и заголовков HTTP-запроса"

**Цель:** Разобрать стартовую строку и обнаружить конец заголовков HTTP-запроса.

---

### 1. Входные события (Символы алфавита)

*   `CHAR` : Любой печатный символ (буквы, цифры, знаки препинания, кроме `\r` и `\n`).
*   `SPACE` : Символ пробела или табуляции.
*   `CR` : Символ возврата каретки (`\r`).
*   `LF` : Символ перевода строки (`\n`).
*   `COLON` : Символ двоеточия (`:`).

---

### 2. Состояния автомата (7 состояний)

1.  **`METHOD`** - Чтение HTTP-метода.
2.  **`URI`** - Чтение URI (пути к ресурсу).
3.  **`VERSION`** - Чтение версии HTTP-протокола.
4.  **`HEADER_NAME`** - Чтение имени заголовка.
5.  **`HEADER_VALUE`** - Чтение значения заголовка.
6.  **`HEADERS_END`** - Обнаружен конец заголовков (успешное завершение).
7.  **`ERROR`** - Состояние ошибки.

---

### 3. Диаграмма переходов

| Текущее состояние | Входное событие | Действие | Следующее состояние |
| :--- | :--- | :--- | :--- |
| **METHOD** | `CHAR` | Накопить символ в буфер метода. | **METHOD** |
| **METHOD** | `SPACE` | Зафиксировать метод. | **URI** |
| **METHOD** | Любое другое | | **ERROR** |
| | | | |
| **URI** | `CHAR`, `SPACE` | Накопить символ в буфер URI. | **URI** |
| **URI** | `SPACE` | Зафиксировать URI. | **VERSION** |
| **URI** | Любое другое | | **ERROR** |
| | | | |
| **VERSION** | `CHAR` | Накопить символ в буфер версии. | **VERSION** |
| **VERSION** | `CR` | Зафиксировать версию. | *(ждем LF)* |
| **VERSION** | `LF` | Зафиксировать версию. | **HEADER_NAME** |
| **VERSION** | Любое другое | | **ERROR** |
| | | | |
| *(ждем LF)* | `LF` | | **HEADER_NAME** |
| *(ждем LF)* | Любое другое | | **ERROR** |
| | | | |
| **HEADER_NAME** | `CHAR` | Накопить символ в буфер имени заголовка. | **HEADER_NAME** |
| **HEADER_NAME** | `COLON` | Зафиксировать имя заголовка. | *(ждем пробел)* |
| **HEADER_NAME** | `CR` | Проверить: если буфер пуст -> конец заголовков. | *(проверка конца)* |
| **HEADER_NAME** | `LF` | Проверить: если буфер пуст -> конец заголовков. | *(проверка конца)* |
| **HEADER_NAME** | Любое другое | | **ERROR** |
| | | | |
| *(ждем пробел)* | `SPACE` | Игнорировать пробелы после двоеточия. | *(ждем пробел)* |
| *(ждем пробел)* | `CHAR`, `CR`, `LF` | | **ERROR** |
| *(ждем пробел)* | Любой печатный символ | Начать чтение значения. | **HEADER_VALUE** |
| | | | |
| **HEADER_VALUE** | `CHAR`, `SPACE` | Накопить символ в буфер значения. | **HEADER_VALUE** |
| **HEADER_VALUE** | `CR` | Зафиксировать значение заголовка. | *(ждем LF для заголовка)* |
| **HEADER_VALUE** | `LF` | Зафиксировать значение заголовка. | **HEADER_NAME** |
| **HEADER_VALUE** | Любое другое | | **ERROR** |
| | | | |
| *(ждем LF для заголовка)* | `LF` | | **HEADER_NAME** |
| *(ждем LF для заголовка)* | Любое другое | | **ERROR** |
| | | | |
| *(проверка конца)* | (есть CR/LF) | Если буфер имени пуст -> это двойной CRLF. | **HEADERS_END** |
| *(проверка конца)* | (есть CR/LF) | Если буфер имени не пуст -> ошибка. | **ERROR** |

---

### 4. Пример работы автомата

**Входная строка:**
```
GET /index.html HTTP/1.1\r\n
Host: example.com\r\n
\r\n
```

1.  **METHOD**: Читаем `G`, `E`, `T`. Получаем `SPACE` -> переход в **URI**.
2.  **URI**: Читаем `/`, `i`, `n`, `d`, `e`, `x`, `.`, `h`, `t`, `m`, `l`. Получаем `SPACE` -> переход в **VERSION**.
3.  **VERSION**: Читаем `H`, `T`, `T`, `P`, `/`, `1`, `.`, `1`. Получаем `CR` -> *(ждем LF)*. Получаем `LF` -> переход в **HEADER_NAME**.
4.  **HEADER_NAME**: Читаем `H`, `o`, `s`, `t`. Получаем `COLON` -> *(ждем пробел)*. Получаем `SPACE` (игнорируем) -> *(ждем пробел)*. Получаем `e` -> переход в **HEADER_VALUE**.
5.  **HEADER_VALUE**: Читаем `e`, `x`, `a`, `m`, `p`, `l`, `e`, `.`, `c`, `o`, `m`. Получаем `CR` -> *(ждем LF для заголовка)*. Получаем `LF` -> переход в **HEADER_NAME**.
6.  **HEADER_NAME**: Буфер имени пуст. Получаем `CR` -> *(проверка конца)*. Буфер пуст -> переход в **HEADERS_END**.

**Результат:** Автомат в состоянии **HEADERS_END**. Стартовая строка и заголовки разобраны успешно.

---

### Что исправлено в этой версии:

1.  **Убраны "плохие" уточнения**: Теперь не важно, является ли символ частью метода или URL — это определяется состоянием автомата (**METHOD**, **URI**).
2.  **Правильная обработка `CR`/`LF`**: Введены промежуточные состояния для обработки пар `CRLF`, что соответствует спецификации HTTP.
3.  **Четкое разделение логики**: Состояние **HEADER_NAME** отвечает за разбор имени до двоеточия, а **HEADER_VALUE** — за разбор значения до конца строки.
4.  **Обнаружение конца заголовков**: Это теперь отдельное состояние (**HEADERS_END**), которое достигается при получении `CR`/`LF` в состоянии **HEADER_NAME** с пустым буфером. Это и есть то "уточняющее условие", которое теперь вынесено в логику перехода между состояниями, а не является свойством входного символа.

