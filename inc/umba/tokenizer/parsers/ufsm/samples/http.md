# Deepseek предлагает разбор HTTP

## Вопрос

> Можешь придумать какой-нибудь конечный автомат, чтобы у него было до 5-7 состояний. 
> Несколько входных событий, и так, чтобы какое-то или какие-то события подразделялись 
> на независимые события и/или уточнялись дополнительными условиями. Может, разбор 
> какого-то протокола, или что-то подобное. Желательно, чтобы это было что-то известное 
> и/или узнаваемое.


Отличная идея! Давайте спроектируем конечный автомат для разбора упрощенной версии **HTTP-запроса**. Это узнаваемо, практично и хорошо ложится на концепцию состояний с уточняющими условиями.

### Конечный автомат: "Парсер HTTP-запроса"

**Цель:** Разобрать входящий поток байтов и определить, является ли он корректным HTTP-запросом, и извлечь его метод и целевой URL.

---

### 1. Входные события (Символы алфавита)

Здесь мы как раз введем независимые события и уточняющие условия.

*   `LETTER` : Любая буква (a-z, A-Z). *Уточняющее условие: является ли эта буква частью метода или URL.*
*   `DIGIT` : Любая цифра (0-9).
*   `SPACE` : Символ пробела (или табуляции).
*   `SLASH` : Символ '/'.
*   `NEWLINE` : Символ перевода строки (`\n`). *Уточняющее условие: является ли он одиночным (`\r\n` vs `\n`) или двойным (конец заголовков).*
*   `OTHER` : Любой другой символ, не попавший в категории выше.

---

### 2. Состояния автомата (6 состояний)

1.  **`START`** - Начальное состояние. Ожидание начала запроса.
2.  **`READ_METHOD`** - Чтение HTTP-метода (GET, POST и т.д.).
3.  **`EXPECT_SPACE_AFTER_METHOD`** - Ожидание пробела после метода.
4.  **`READ_URI`** - Чтение URI (пути к ресурсу, например, `/index.html`).
5.  **`EXPECT_SPACE_AFTER_URI`** - Ожидание пробела после URI.
6.  **`READ_VERSION`** - Чтение версии HTTP-протокола (например, `HTTP/1.1`).
7.  **`EXPECT_NEWLINE`** - Ожидание перевода строки для завершения стартовой строки.
8.  **`ERROR`** - Состояние ошибки. Любое некорректное событие переводит автомат сюда.
9.  **`SUCCESS`** - Успешный разбор стартовой строки запроса.

---

### 3. Диаграмма переходов (описательно)

| Текущее состояние | Входное событие | Условие / Действие | Следующее состояние |
| :--- | :--- | :--- | :--- |
| **START** | `LETTER` | Начинаем записывать метод. | **READ_METHOD** |
| **START** | Любое другое | | **ERROR** |
| | | | |
| **READ_METHOD** | `LETTER` | Продолжаем записывать метод. | **READ_METHOD** |
| **READ_METHOD** | `SPACE` | Метод прочитан. Проверить, является ли он допустимым (GET, POST...). | **EXPECT_SPACE_AFTER_METHOD** |
| **READ_METHOD** | Любое другое | | **ERROR** |
| | | | |
| **EXPECT_SPACE_AFTER_METHOD** | `SPACE` | Игнорируем лишние пробелы. | **EXPECT_SPACE_AFTER_METHOD** |
| **EXPECT_SPACE_AFTER_METHOD** | `SLASH` | Начинается URI. Начать записывать URI. | **READ_URI** |
| **EXPECT_SPACE_AFTER_METHOD** | Любое другое | | **ERROR** |
| | | | |
| **READ_URI** | `LETTER`, `DIGIT`, `SLASH`, `OTHER` (допустимый) | Продолжаем записывать URI. | **READ_URI** |
| **READ_URI** | `SPACE` | URI прочитан. | **EXPECT_SPACE_AFTER_URI** |
| **READ_URI** | Любое другое (недопустимый символ для URI) | | **ERROR** |
| | | | |
| **EXPECT_SPACE_AFTER_URI** | `SPACE` | Игнорируем лишние пробелы. | **EXPECT_SPACE_AFTER_URI** |
| **EXPECT_SPACE_AFTER_URI** | `LETTER` | Первая буква версии ('H' из "HTTP"). Начать записывать версию. | **READ_VERSION** |
| **EXPECT_SPACE_AFTER_URI** | Любое другое | | **ERROR** |
| | | | |
| **READ_VERSION** | `LETTER`, `DIGIT`, `SLASH`, `.` | Продолжаем записывать версию. | **READ_VERSION** |
| **READ_VERSION** | `NEWLINE` | Проверить, что версия имеет формат `HTTP/x.y`. | **SUCCESS** |
| **READ_VERSION** | Любое другое | | **ERROR** |
| | | | |
| **SUCCESS** | (Конец работы автомата для этой задачи) | | |
| **ERROR** | (Конец работы автомата) | | |

---

### 4. Пример работы автомата

**Входная строка:** `GET /index.html HTTP/1.1\n`

1.  **START**: Видим `G` (`LETTER`) -> Переход в **READ_METHOD**. Метод = "G".
2.  **READ_METHOD**: Видим `E` (`LETTER`) -> Метод = "GE". Остаемся в **READ_METHOD**.
3.  **READ_METHOD**: Видим `T` (`LETTER`) -> Метод = "GET". Остаемся в **READ_METHOD**.
4.  **READ_METHOD**: Видим ` ` (`SPACE`) -> Переход в **EXPECT_SPACE_AFTER_METHOD**. Метод "GET" корректен.
5.  **EXPECT_SPACE_AFTER_METHOD**: Видим `/` (`SLASH`) -> Переход в **READ_URI**. URI = "/".
6.  **READ_URI**: Видим `i` (`LETTER`) -> URI = "/i". Остаемся в **READ_URI**.
    *   ... (читаем `index.html`) ...
7.  **READ_URI**: Видим ` ` (`SPACE`) -> Переход в **EXPECT_SPACE_AFTER_URI**.
8.  **EXPECT_SPACE_AFTER_URI**: Видим `H` (`LETTER`) -> Переход в **READ_VERSION**. Версия = "H".
9.  **READ_VERSION**: Читаем оставшуюся часть `TTP/1.1`.
10. **READ_VERSION**: Видим `\n` (`NEWLINE`) -> Переход в **SUCCESS**.

**Результат:** Автомат в состоянии **SUCCESS**. Извлеченные данные: Метод = `GET`, URI = `/index.html`, Версия = `HTTP/1.1`.

---

### 5. Пример с ошибкой

**Входная строка:** `GETT /index.html HTTP/1.1\n`

1.  ... Автомат соберет метод "GETT".
2.  В состоянии **READ_METHOD** при получении `SPACE` автомат проверяет уточняющее условие: "Является ли собранный метод допустимым?".
3.  "GETT" не является стандартным HTTP-методом -> Переход в состояние **ERROR**.

Этот автомат наглядно показывает:
*   **Конечное число состояний**.
*   **Независимые входные события** (`LETTER`, `DIGIT` и т.д.).
*   **Уточняющие условия**, проверяемые при переходах (валидность метода, версии).
*   **Узнаваемость** (разбор HTTP).
*   **Практическую применимость** (такие автоматы лежат в основе парсеров веб-серверов).


## Вопрос

> NEWLINE - тут не должно быть уточняющего условия, а, вероятно, должно быть добавлено ещё одно состояние. 
> Скорее всего, даже это и не требуется. В ожидании выражения HTTP-заголовка (сюда попадаем после окончания 
> предыдущего заголовка по переводу строки), если получаем перевод строки - то разбор заголовков можно 
> считать законченным.
>
> LETTER - является ли символ частью метода или URL - должно определяться состоянием автомата, ты придумал 
> плохой пример. Подумай лучше.


Вы абсолютно правы, мои примеры условий были некорректны. Давайте перепроектируем автомат правильно, чтобы логика определялась именно состояниями, а не уточнениями в событиях.

### Конечный автомат: "Парсер стартовой строки и заголовков HTTP-запроса"

**Цель:** Разобрать стартовую строку и обнаружить конец заголовков HTTP-запроса.

---

### 1. Входные события (Символы алфавита)

*   `CHAR` : Любой печатный символ (буквы, цифры, знаки препинания, кроме `\r` и `\n`).
*   `SPACE` : Символ пробела или табуляции.
*   `CR` : Символ возврата каретки (`\r`).
*   `LF` : Символ перевода строки (`\n`).
*   `COLON` : Символ двоеточия (`:`).

---

### 2. Состояния автомата (7 состояний)

1.  **`METHOD`** - Чтение HTTP-метода.
2.  **`URI`** - Чтение URI (пути к ресурсу).
3.  **`VERSION`** - Чтение версии HTTP-протокола.
4.  **`HEADER_NAME`** - Чтение имени заголовка.
5.  **`HEADER_VALUE`** - Чтение значения заголовка.
6.  **`HEADERS_END`** - Обнаружен конец заголовков (успешное завершение).
7.  **`ERROR`** - Состояние ошибки.

---

### 3. Диаграмма переходов

| Текущее состояние | Входное событие | Действие | Следующее состояние |
| :--- | :--- | :--- | :--- |
| **METHOD** | `CHAR` | Накопить символ в буфер метода. | **METHOD** |
| **METHOD** | `SPACE` | Зафиксировать метод. | **URI** |
| **METHOD** | Любое другое | | **ERROR** |
| | | | |
| **URI** | `CHAR`, `SPACE` | Накопить символ в буфер URI. | **URI** |
| **URI** | `SPACE` | Зафиксировать URI. | **VERSION** |
| **URI** | Любое другое | | **ERROR** |
| | | | |
| **VERSION** | `CHAR` | Накопить символ в буфер версии. | **VERSION** |
| **VERSION** | `CR` | Зафиксировать версию. | *(ждем LF)* |
| **VERSION** | `LF` | Зафиксировать версию. | **HEADER_NAME** |
| **VERSION** | Любое другое | | **ERROR** |
| | | | |
| *(ждем LF)* | `LF` | | **HEADER_NAME** |
| *(ждем LF)* | Любое другое | | **ERROR** |
| | | | |
| **HEADER_NAME** | `CHAR` | Накопить символ в буфер имени заголовка. | **HEADER_NAME** |
| **HEADER_NAME** | `COLON` | Зафиксировать имя заголовка. | *(ждем пробел)* |
| **HEADER_NAME** | `CR` | Проверить: если буфер пуст -> конец заголовков. | *(проверка конца)* |
| **HEADER_NAME** | `LF` | Проверить: если буфер пуст -> конец заголовков. | *(проверка конца)* |
| **HEADER_NAME** | Любое другое | | **ERROR** |
| | | | |
| *(ждем пробел)* | `SPACE` | Игнорировать пробелы после двоеточия. | *(ждем пробел)* |
| *(ждем пробел)* | `CHAR`, `CR`, `LF` | | **ERROR** |
| *(ждем пробел)* | Любой печатный символ | Начать чтение значения. | **HEADER_VALUE** |
| | | | |
| **HEADER_VALUE** | `CHAR`, `SPACE` | Накопить символ в буфер значения. | **HEADER_VALUE** |
| **HEADER_VALUE** | `CR` | Зафиксировать значение заголовка. | *(ждем LF для заголовка)* |
| **HEADER_VALUE** | `LF` | Зафиксировать значение заголовка. | **HEADER_NAME** |
| **HEADER_VALUE** | Любое другое | | **ERROR** |
| | | | |
| *(ждем LF для заголовка)* | `LF` | | **HEADER_NAME** |
| *(ждем LF для заголовка)* | Любое другое | | **ERROR** |
| | | | |
| *(проверка конца)* | (есть CR/LF) | Если буфер имени пуст -> это двойной CRLF. | **HEADERS_END** |
| *(проверка конца)* | (есть CR/LF) | Если буфер имени не пуст -> ошибка. | **ERROR** |

---

### 4. Пример работы автомата

**Входная строка:**
```
GET /index.html HTTP/1.1\r\n
Host: example.com\r\n
\r\n
```

1.  **METHOD**: Читаем `G`, `E`, `T`. Получаем `SPACE` -> переход в **URI**.
2.  **URI**: Читаем `/`, `i`, `n`, `d`, `e`, `x`, `.`, `h`, `t`, `m`, `l`. Получаем `SPACE` -> переход в **VERSION**.
3.  **VERSION**: Читаем `H`, `T`, `T`, `P`, `/`, `1`, `.`, `1`. Получаем `CR` -> *(ждем LF)*. Получаем `LF` -> переход в **HEADER_NAME**.
4.  **HEADER_NAME**: Читаем `H`, `o`, `s`, `t`. Получаем `COLON` -> *(ждем пробел)*. Получаем `SPACE` (игнорируем) -> *(ждем пробел)*. Получаем `e` -> переход в **HEADER_VALUE**.
5.  **HEADER_VALUE**: Читаем `e`, `x`, `a`, `m`, `p`, `l`, `e`, `.`, `c`, `o`, `m`. Получаем `CR` -> *(ждем LF для заголовка)*. Получаем `LF` -> переход в **HEADER_NAME**.
6.  **HEADER_NAME**: Буфер имени пуст. Получаем `CR` -> *(проверка конца)*. Буфер пуст -> переход в **HEADERS_END**.

**Результат:** Автомат в состоянии **HEADERS_END**. Стартовая строка и заголовки разобраны успешно.

---

### Что исправлено в этой версии:

1.  **Убраны "плохие" уточнения**: Теперь не важно, является ли символ частью метода или URL — это определяется состоянием автомата (**METHOD**, **URI**).
2.  **Правильная обработка `CR`/`LF`**: Введены промежуточные состояния для обработки пар `CRLF`, что соответствует спецификации HTTP.
3.  **Четкое разделение логики**: Состояние **HEADER_NAME** отвечает за разбор имени до двоеточия, а **HEADER_VALUE** — за разбор значения до конца строки.
4.  **Обнаружение конца заголовков**: Это теперь отдельное состояние (**HEADERS_END**), которое достигается при получении `CR`/`LF` в состоянии **HEADER_NAME** с пустым буфером. Это и есть то "уточняющее условие", которое теперь вынесено в логику перехода между состояниями, а не является свойством входного символа.


## Вопрос

> Может ли в протоколе HTTP заголовок располагаться на нескольких строках? 
> И если да, то какой способ используется для продолжения заголовка на следующей строке?


Отличный вопрос. Ответ на него имеет два аспекта: строго по стандарту и на практике.

### Краткий ответ

**Нет, согласно стандарту HTTP, каждая строка заголовка должна находиться на отдельной физической строке.** Перенос значения заголовка на следующую строку не разрешен простым разрывом строки.

Однако существует практический способ сделать длинное значение заголовка более читаемым, который поддерживается большинством клиентов и серверов.

### Подробное объяснение

#### 1. Строго по спецификации (RFC 7230)

Спецификация HTTP (RFC 7230, Section 3.2) четко определяет формат полей заголовка:

*   Каждое поле заголовка представляется в виде одной строки.
*   Строка состоит из имени поля, за которым следует двоеточие (`:`), пробел и значение поля.
*   Заголовки разделяются парой символов CRLF (Carriage Return + Line Feed, `\r\n`).

Пример корректного набора заголовков:
```
Host: www.example.com
User-Agent: Mozilla/5.0
Content-Type: application/json
```
Если вы просто перенесете значение на новую строку, это будет считаться синтаксической ошибкой, и такой запрос/ответ будет отклонен.
```
Content-Type: application/
json
```
Так делать **НЕЛЬЗЯ**. Сервер или клиент интерпретирует слово `json` как начало нового заголовка с именем "json", что вызовет ошибку парсинга.

#### 2. Практический способ "переноса" (Header Folding)

Несмотря на запрет простого переноса, в RFC 7230 (унаследовано от более ранних версий) описан механизм **"folding" (сворачивание)** или **"line folding"**.

**Способ:** Продолжение строки заголовка начинается с одного или более пробелов или символов табуляции.

Формат:
```
Длинный-Заголовок: значение-заголовка начинается здесь,
   а продолжается на этой строке, которая начинается с пробелов.
   И может продолжаться дальше, снова начиная строку с пробелов.
```

Пример реального заголовка:
```
X-Custom-Long-Header: Это очень длинное значение одного заголовка,
    которое для удобства чтения человеком было разбито на несколько
    строк. Каждая последующая строка начинается с пробела.
```

**Важные нюансы:**

1.  **Только для удобства чтения:** Этот метод изначально предназначался для того, чтобы сделать сырые HTTP-сообщения более читаемыми для людей (например, при просмотре в текстовом редакторе или логировании).
2.  **Обязательный пробел/табуляция:** Строка-продолжение **обязана** начинаться как минимум с одного пробела (SP, `0x20`) или символа табуляции (HT, `\t`, `0x09`).
3.  **При парсинге пробелы сохраняются:** При обработке сообщения получатель должен "свернуть" эти строки обратно в одну. Пробелы в начале строк-продолжений становятся частью значения заголовка.
4.  **Устаревшая практика:** **Важное замечание:** В RFC 7230 (2014 год) этот механизм folding был объявлен устаревшим (`obsolete`). Создателям новых протоколов и реализаций рекомендуется его не использовать.

#### Современный подход

Поскольку `folding` устарел, а необходимость в длинных заголовках осталась, современное ПО придерживается простого правила:

**Каждый заголовок — одна строка, какой бы длинной она ни была.**

Современные парсеры (в браузерах, веб-серверах, библиотеках) ожидают именно такой структуры. Они легко обрабатывают очень длинные строки.

Если вам нужно отправить структурированные данные в одном заголовке (например, `Cache-Control`), используется определенный синтаксис, где значения перечисляются через запятую внутри одной строки:

```
Cache-Control: public, max-age=604800, must-revalidate, s-maxage=86400
```

### Вывод

1.  **Строго по стандарту:** Нет, заголовок не может располагаться на нескольких строках путем простого разрыва.
2.  **Исторически / для удобства чтения:** Да, можно использовать "folding", начиная строки-продолжения с пробела или табуляции. **Но эта практика устарела.**
3.  **Современная практика:** Заголовок всегда должен быть представлен одной непрерывной строкой. Все современные HTTP-парсеры рассчитаны на это. Если вы пишете код, генерирующий HTTP-сообщения, придерживайтесь этого правила. Если вы видите "свернутый" заголовок в логах, знайте, что это всего лишь визуальное форматирование.


## Вопрос

> Если я пишу универсальный HTTP-сервер, или клиент, надо ли мне поддерживать обработку folding'а заголовков, 
> или просто отвечать ошибкой (на сервере), или отбрасывать ответ (на клиенте)?


**Однозначный рекомендательный ответ: Нет, не нужно поддерживать folding.**

Это устаревшая функциональность, и её поддержка в современной реализации принесет больше проблем, чем пользы.

## Почне не стоит поддерживать folding:

### 1. **Стандарт явно объявляет его устаревшим**
RFC 7230 (Section 3.2.4) прямо говорит:
> "This specification obsoletes the line folding functionality..."

### 2. **Современные реализации не используют folding**
- Все современные браузеры (Chrome, Firefox, Safari, Edge) генерируют заголовки в одну строку
- Популярные HTTP-библиотеки (requests, axios, fetch API) не используют folding
- Веб-серверы (nginx, Apache) и фреймворки (Express, Django, Spring) не генерируют такие заголовки

### 3. **Проблемы безопасности**
Поддержка folding может создать уязвимости:
- **Request/Response Smuggling** - злоумышленник может использовать неоднозначность в парсинге
- **Различия в обработке** между вашим сервером и прокси может привести к атакам

### 4. **Сложность реализации**
- Нужно корректно обрабатывать разные виды пробелов (SP, HTAB)
- Учитывать, что пробелы становятся частью значения заголовка
- Тестировать множество edge-cases

## Рекомендуемая стратегия обработки:

### Для HTTP-сервера:
```python
def parse_headers(header_lines):
    headers = {}
    for line in header_lines:
        # Отвергаем строки, начинающиеся с пробела/табуляции
        if line.startswith((' ', '\t')):
            return 400, "Bad Request: Obsolete header folding detected"
        
        # Стандартный парсинг
        if ':' in line:
            name, value = line.split(':', 1)
            headers[name.strip()] = value.strip()
    
    return headers
```

### Для HTTP-клиента:
```python
def handle_response(response):
    # Проверяем на folding перед парсингом
    for line in response.header_lines:
        if line.startswith((' ', '\t')):
            raise ValueError("Server sent obsolete folded headers")
    
    # Парсим стандартные заголовки
    return parse_standard_headers(response.header_lines)
```

## Что делать на практике:

1. **Серверу** следует возвращать `400 Bad Request` при обнаружении folded headers
2. **Клиенту** следует либо:
   - Отбрасывать ответ с folded headers как невалидный
   - Игнорировать проблему и пытаться парсить (менее безопасно)
   - Логировать предупреждение и продолжать работу

## Исключения:
Единственный случай, когда может потребоваться поддержка folding - это если вы пишете:
- Исторический/археологический HTTP-парсер для старых систем
- Анализатор логов, где могут встречаться старые форматы
- Совместимый клиент/сервер для унаследованных систем

**Для универсального современного HTTP-компонента поддержка folding не нужна и не рекомендуется.** Сосредоточьтесь на корректной обработке стандартных однострочных заголовков.


